# React Flickering Grid Background
URL: /background/flickering-grid
React flickering grid background with CRT monitor effects. Canvas-based subtle visual noise animations using TypeScript and shadcn/ui styling.

***

title: React Flickering Grid Background
description: React flickering grid background with CRT monitor effects. Canvas-based subtle visual noise animations using TypeScript and shadcn/ui styling.
icon: Grid2x2
component: true
---------------

<PoweredBy
  packages={[
  {
    name: "Canvas API",
    url: "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
  },
  {
    name: "Intersection Observer API",
    url: "https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API",
  },
]}
/>

<Callout title="Trying to implement subtle grid animations?">
  [Join our Discord community](https://discord.com/invite/Z9NVtNE7bj) for help
  from other developers.
</Callout>

<br />

Remember those old CRT monitors when they'd flicker and show static? This React component recreates that ambient digital noise, but in a good way. Tiny squares randomly flicker in and out of existence, creating a subtle living texture that suggests activity without being distracting.

### Ambient flickering animation

Watch squares randomly appear and fade with organic timing:

<Preview path="background/flickering-grid-basic" />

Built for React applications with TypeScript and Next.js. The animation runs on HTML5 Canvas using `requestAnimationFrame` for smooth 60fps flickering. Intersection Observer pauses the animation when off-screen, so your battery doesn't drain powering invisible pixels.

## Installation

<Installer packageName="flickering-grid" />

## Usage

```tsx
import { FlickeringGrid } from "@/components/ui/flickering-grid";

export default function Dashboard() {
  return (
    <div className="relative h-screen">
      <FlickeringGrid
        className="absolute inset-0"
        squareSize={4}
        gridGap={6}
        flickerChance={0.3}
        color="rgb(100, 100, 100)"
        maxOpacity={0.2}
      />
      <div className="relative z-10">
        <h1>Your content appears above the flickering</h1>
      </div>
    </div>
  );
}
```

## Why most grid animations feel mechanical

Most developers use CSS animations or simple JavaScript timers. The grid flickers in patterns—predictable, robotic, obviously computer-generated. Some try to randomize with Math.random(), but it's still just uniform distribution. Real static has clustering and gaps.

This React component uses weighted probability for organic flickering. Squares have a `flickerChance` per frame, but the timing creates natural clusters of activity. Canvas rendering with Float32Array keeps thousands of squares performant. Intersection Observer stops the animation when you're not looking, because why waste CPU on invisible pixels?

## Features

* **Canvas-based rendering** with Float32Array for thousands of squares
* **Organic flickering patterns** using weighted probability timing
* **Performance optimized** with Intersection Observer auto-pause
* **High DPI support** automatically adapting to device pixel ratio
* **Responsive sizing** using ResizeObserver for container changes
* **TypeScript definitions** for all animation and visual parameters
* **Memory efficient** implementation preventing browser lag
* **shadcn/ui compatible** with proper z-index layering

## API Reference

### FlickeringGrid

Main component for the ambient flickering grid animation.

| Prop            | Type     | Default          | Description                                       |
| --------------- | -------- | ---------------- | ------------------------------------------------- |
| `squareSize`    | `number` | `4`              | Size of each square in pixels (2-8 recommended)   |
| `gridGap`       | `number` | `6`              | Gap between squares in pixels (3-12 recommended)  |
| `flickerChance` | `number` | `0.3`            | Probability of flicker per frame (0-1)            |
| `color`         | `string` | `"rgb(0, 0, 0)"` | Square color (any valid CSS color format)         |
| `width`         | `number` | -                | Fixed width (auto-detects container if omitted)   |
| `height`        | `number` | -                | Fixed height (auto-detects container if omitted)  |
| `className`     | `string` | -                | Additional Tailwind CSS classes                   |
| `maxOpacity`    | `number` | `0.3`            | Maximum square opacity (0-1, lower = more subtle) |

## Common gotchas

**Performance with large grids**: Each square is tracked in a Float32Array. Very large containers (4K+ pixels) might impact performance. Consider reducing squareSize or increasing gridGap.

**Z-index content layering**: Your content needs `relative z-10` or higher. The grid sits at base level to avoid interfering with interactions.

**Color format flexibility**: Supports any CSS color (hex, rgb, hsl, named colors), but gets converted to RGBA internally for opacity manipulation.

**Intersection Observer edge cases**: Animation pauses when not visible. If you need it always running (for screen recording), you'd need to modify the component.

**Canvas sizing on mobile**: The grid auto-resizes to container dimensions. On very small screens, reduce squareSize to maintain proper density.

## You might also like

Explore other subtle background components for React applications:

<Cards>
  <Card href="/background/dot-pattern" title="Dot Pattern" description="Minimalist dot grids with optional glow effects" />

  <Card href="/background/grid-pattern" title="Grid Pattern" description="Clean line grids with various styles and animations" />

  <Card href="/background/noise" title="Noise" description="Organic texture patterns with customizable grain" />

  <Card href="/background/interactive-grid-pattern" title="Interactive Grid Pattern" description="Grid cells that respond to hover interactions" />

  <Card href="/background/boxes" title="Background Boxes" description="Isometric grid with colorful hover effects" />

  <Card href="/background/squares" title="Squares Background" description="Floating square elements with smooth animations" />
</Cards>

## Questions developers actually ask

<Accordions type="single">
  <Accordion id="flicker-intensity" title="How do I control the flickering intensity?">
    Use `flickerChance` (0-1) for frequency and `maxOpacity` (0-1) for visibility. Lower values = more subtle. Try flickerChance: 0.1, maxOpacity: 0.15 for barely-there ambient effect.
  </Accordion>

  <Accordion id="color-customization" title="Can I use brand colors or gradients?">
    Pass any CSS color to the `color` prop: hex (#ff0000), rgb, hsl, or named colors. Gradients won't work—each square needs a solid color for opacity animation.
  </Accordion>

  <Accordion id="grid-density" title="How do I make the grid denser or sparser?">
    Smaller `squareSize` and `gridGap` = denser grid. Larger values = sparser. For dense: squareSize: 2, gridGap: 3. For sparse: squareSize: 6, gridGap: 12.
  </Accordion>

  <Accordion id="disable-pause" title="Can I keep it running when not visible?">
    The Intersection Observer optimization is hardcoded. To keep it always running, you'd need to remove the observer logic from the component. Usually not needed.
  </Accordion>

  <Accordion id="synchronize-flickers" title="How do I sync flickers across multiple grids?">
    Each grid instance has independent timing. To sync them, you'd need shared state or a central timer. Usually organic variation looks better than perfect sync.
  </Accordion>

  <Accordion id="canvas-styling" title="Can I add borders or effects to the canvas?">
    Use the `className` prop to style the container. The canvas itself fills the container and ignores pointer events to avoid interfering with overlaid content.
  </Accordion>
</Accordions>
